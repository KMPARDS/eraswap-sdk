/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface IRelayHubInterface extends ethers.utils.Interface {
  functions: {
    "balanceOf(address)": FunctionFragment;
    "canRelay(address,address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)": FunctionFragment;
    "depositFor(address)": FunctionFragment;
    "getNonce(address)": FunctionFragment;
    "getRelay(address)": FunctionFragment;
    "maxPossibleCharge(uint256,uint256,uint256)": FunctionFragment;
    "penalizeIllegalTransaction(bytes,bytes)": FunctionFragment;
    "penalizeRepeatedNonce(bytes,bytes,bytes,bytes)": FunctionFragment;
    "registerRelay(uint256,string)": FunctionFragment;
    "relayCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)": FunctionFragment;
    "removeRelayByOwner(address)": FunctionFragment;
    "requiredGas(uint256)": FunctionFragment;
    "stake(address,uint256)": FunctionFragment;
    "unstake(address)": FunctionFragment;
    "withdraw(uint256,address)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
  encodeFunctionData(
    functionFragment: "canRelay",
    values: [
      string,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(functionFragment: "depositFor", values: [string]): string;
  encodeFunctionData(functionFragment: "getNonce", values: [string]): string;
  encodeFunctionData(functionFragment: "getRelay", values: [string]): string;
  encodeFunctionData(
    functionFragment: "maxPossibleCharge",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "penalizeIllegalTransaction",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "penalizeRepeatedNonce",
    values: [BytesLike, BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerRelay",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "relayCall",
    values: [
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "removeRelayByOwner",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "requiredGas",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "stake",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "unstake", values: [string]): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [BigNumberish, string]
  ): string;

  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "canRelay", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "depositFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getNonce", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getRelay", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "maxPossibleCharge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "penalizeIllegalTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "penalizeRepeatedNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerRelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "relayCall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeRelayByOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requiredGas",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "unstake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "CanRelayFailed(address,address,address,bytes4,uint256)": EventFragment;
    "Deposited(address,address,uint256)": EventFragment;
    "Penalized(address,address,uint256)": EventFragment;
    "RelayAdded(address,address,uint256,uint256,uint256,string)": EventFragment;
    "RelayRemoved(address,uint256)": EventFragment;
    "Staked(address,uint256,uint256)": EventFragment;
    "TransactionRelayed(address,address,address,bytes4,uint8,uint256)": EventFragment;
    "Unstaked(address,uint256)": EventFragment;
    "Withdrawn(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CanRelayFailed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Penalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RelayAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RelayRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Staked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionRelayed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unstaked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawn"): EventFragment;
}

export class IRelayHub extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: IRelayHubInterface;

  functions: {
    /**
     * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    balanceOf(
      target: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    "balanceOf(address)"(
      target: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
     */
    canRelay(
      relay: string,
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      status: BigNumber;
      recipientContext: string;
      0: BigNumber;
      1: string;
    }>;

    /**
     * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
     */
    "canRelay(address,address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
      relay: string,
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      status: BigNumber;
      recipientContext: string;
      0: BigNumber;
      1: string;
    }>;

    /**
     * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
     */
    depositFor(
      target: string,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
     */
    "depositFor(address)"(
      target: string,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * Returns an account's nonce in `RelayHub`.
     */
    getNonce(
      from: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Returns an account's nonce in `RelayHub`.
     */
    "getNonce(address)"(
      from: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
     */
    getRelay(
      relay: string,
      overrides?: CallOverrides
    ): Promise<{
      totalStake: BigNumber;
      unstakeDelay: BigNumber;
      unstakeTime: BigNumber;
      owner: string;
      state: number;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: string;
      4: number;
    }>;

    /**
     * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
     */
    "getRelay(address)"(
      relay: string,
      overrides?: CallOverrides
    ): Promise<{
      totalStake: BigNumber;
      unstakeDelay: BigNumber;
      unstakeTime: BigNumber;
      owner: string;
      state: number;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: string;
      4: number;
    }>;

    /**
     * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    maxPossibleCharge(
      relayedCallStipend: BigNumberish,
      gasPrice: BigNumberish,
      transactionFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    "maxPossibleCharge(uint256,uint256,uint256)"(
      relayedCallStipend: BigNumberish,
      gasPrice: BigNumberish,
      transactionFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    penalizeIllegalTransaction(
      unsignedTx: BytesLike,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    "penalizeIllegalTransaction(bytes,bytes)"(
      unsignedTx: BytesLike,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
     */
    penalizeRepeatedNonce(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
     */
    "penalizeRepeatedNonce(bytes,bytes,bytes,bytes)"(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
     */
    registerRelay(
      transactionFee: BigNumberish,
      url: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
     */
    "registerRelay(uint256,string)"(
      transactionFee: BigNumberish,
      url: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
     */
    relayCall(
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
     */
    "relayCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
     */
    removeRelayByOwner(
      relay: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
     */
    "removeRelayByOwner(address)"(
      relay: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
     */
    requiredGas(
      relayedCallStipend: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
     */
    "requiredGas(uint256)"(
      relayedCallStipend: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
     */
    stake(
      relayaddr: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
     */
    "stake(address,uint256)"(
      relayaddr: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
     */
    unstake(relay: string, overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
     */
    "unstake(address)"(
      relay: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
     */
    withdraw(
      amount: BigNumberish,
      dest: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
     */
    "withdraw(uint256,address)"(
      amount: BigNumberish,
      dest: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  /**
   * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
   */
  balanceOf(target: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
   */
  "balanceOf(address)"(
    target: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
   */
  canRelay(
    relay: string,
    from: string,
    to: string,
    encodedFunction: BytesLike,
    transactionFee: BigNumberish,
    gasPrice: BigNumberish,
    gasLimit: BigNumberish,
    nonce: BigNumberish,
    signature: BytesLike,
    approvalData: BytesLike,
    overrides?: CallOverrides
  ): Promise<{
    status: BigNumber;
    recipientContext: string;
    0: BigNumber;
    1: string;
  }>;

  /**
   * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
   */
  "canRelay(address,address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
    relay: string,
    from: string,
    to: string,
    encodedFunction: BytesLike,
    transactionFee: BigNumberish,
    gasPrice: BigNumberish,
    gasLimit: BigNumberish,
    nonce: BigNumberish,
    signature: BytesLike,
    approvalData: BytesLike,
    overrides?: CallOverrides
  ): Promise<{
    status: BigNumber;
    recipientContext: string;
    0: BigNumber;
    1: string;
  }>;

  /**
   * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
   */
  depositFor(
    target: string,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
   */
  "depositFor(address)"(
    target: string,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * Returns an account's nonce in `RelayHub`.
   */
  getNonce(from: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns an account's nonce in `RelayHub`.
   */
  "getNonce(address)"(
    from: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
   */
  getRelay(
    relay: string,
    overrides?: CallOverrides
  ): Promise<{
    totalStake: BigNumber;
    unstakeDelay: BigNumber;
    unstakeTime: BigNumber;
    owner: string;
    state: number;
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: string;
    4: number;
  }>;

  /**
   * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
   */
  "getRelay(address)"(
    relay: string,
    overrides?: CallOverrides
  ): Promise<{
    totalStake: BigNumber;
    unstakeDelay: BigNumber;
    unstakeTime: BigNumber;
    owner: string;
    state: number;
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: string;
    4: number;
  }>;

  /**
   * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
   */
  maxPossibleCharge(
    relayedCallStipend: BigNumberish,
    gasPrice: BigNumberish,
    transactionFee: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
   */
  "maxPossibleCharge(uint256,uint256,uint256)"(
    relayedCallStipend: BigNumberish,
    gasPrice: BigNumberish,
    transactionFee: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
   */
  penalizeIllegalTransaction(
    unsignedTx: BytesLike,
    signature: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
   */
  "penalizeIllegalTransaction(bytes,bytes)"(
    unsignedTx: BytesLike,
    signature: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
   */
  penalizeRepeatedNonce(
    unsignedTx1: BytesLike,
    signature1: BytesLike,
    unsignedTx2: BytesLike,
    signature2: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
   */
  "penalizeRepeatedNonce(bytes,bytes,bytes,bytes)"(
    unsignedTx1: BytesLike,
    signature1: BytesLike,
    unsignedTx2: BytesLike,
    signature2: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
   */
  registerRelay(
    transactionFee: BigNumberish,
    url: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
   */
  "registerRelay(uint256,string)"(
    transactionFee: BigNumberish,
    url: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
   */
  relayCall(
    from: string,
    to: string,
    encodedFunction: BytesLike,
    transactionFee: BigNumberish,
    gasPrice: BigNumberish,
    gasLimit: BigNumberish,
    nonce: BigNumberish,
    signature: BytesLike,
    approvalData: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
   */
  "relayCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
    from: string,
    to: string,
    encodedFunction: BytesLike,
    transactionFee: BigNumberish,
    gasPrice: BigNumberish,
    gasLimit: BigNumberish,
    nonce: BigNumberish,
    signature: BytesLike,
    approvalData: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
   */
  removeRelayByOwner(
    relay: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
   */
  "removeRelayByOwner(address)"(
    relay: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
   */
  requiredGas(
    relayedCallStipend: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
   */
  "requiredGas(uint256)"(
    relayedCallStipend: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
   */
  stake(
    relayaddr: string,
    unstakeDelay: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
   */
  "stake(address,uint256)"(
    relayaddr: string,
    unstakeDelay: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
   */
  unstake(relay: string, overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
   */
  "unstake(address)"(
    relay: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
   */
  withdraw(
    amount: BigNumberish,
    dest: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
   */
  "withdraw(uint256,address)"(
    amount: BigNumberish,
    dest: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    balanceOf(target: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    "balanceOf(address)"(
      target: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
     */
    canRelay(
      relay: string,
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      status: BigNumber;
      recipientContext: string;
      0: BigNumber;
      1: string;
    }>;

    /**
     * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
     */
    "canRelay(address,address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
      relay: string,
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      status: BigNumber;
      recipientContext: string;
      0: BigNumber;
      1: string;
    }>;

    /**
     * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
     */
    depositFor(target: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
     */
    "depositFor(address)"(
      target: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns an account's nonce in `RelayHub`.
     */
    getNonce(from: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns an account's nonce in `RelayHub`.
     */
    "getNonce(address)"(
      from: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
     */
    getRelay(
      relay: string,
      overrides?: CallOverrides
    ): Promise<{
      totalStake: BigNumber;
      unstakeDelay: BigNumber;
      unstakeTime: BigNumber;
      owner: string;
      state: number;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: string;
      4: number;
    }>;

    /**
     * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
     */
    "getRelay(address)"(
      relay: string,
      overrides?: CallOverrides
    ): Promise<{
      totalStake: BigNumber;
      unstakeDelay: BigNumber;
      unstakeTime: BigNumber;
      owner: string;
      state: number;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: string;
      4: number;
    }>;

    /**
     * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    maxPossibleCharge(
      relayedCallStipend: BigNumberish,
      gasPrice: BigNumberish,
      transactionFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    "maxPossibleCharge(uint256,uint256,uint256)"(
      relayedCallStipend: BigNumberish,
      gasPrice: BigNumberish,
      transactionFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    penalizeIllegalTransaction(
      unsignedTx: BytesLike,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    "penalizeIllegalTransaction(bytes,bytes)"(
      unsignedTx: BytesLike,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
     */
    penalizeRepeatedNonce(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
     */
    "penalizeRepeatedNonce(bytes,bytes,bytes,bytes)"(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
     */
    registerRelay(
      transactionFee: BigNumberish,
      url: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
     */
    "registerRelay(uint256,string)"(
      transactionFee: BigNumberish,
      url: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
     */
    relayCall(
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
     */
    "relayCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
     */
    removeRelayByOwner(relay: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
     */
    "removeRelayByOwner(address)"(
      relay: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
     */
    requiredGas(
      relayedCallStipend: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
     */
    "requiredGas(uint256)"(
      relayedCallStipend: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
     */
    stake(
      relayaddr: string,
      unstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
     */
    "stake(address,uint256)"(
      relayaddr: string,
      unstakeDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
     */
    unstake(relay: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
     */
    "unstake(address)"(relay: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
     */
    withdraw(
      amount: BigNumberish,
      dest: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
     */
    "withdraw(uint256,address)"(
      amount: BigNumberish,
      dest: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    CanRelayFailed(
      relay: string | null,
      from: string | null,
      to: string | null,
      selector: null,
      reason: null
    ): EventFilter;

    Deposited(
      recipient: string | null,
      from: string | null,
      amount: null
    ): EventFilter;

    Penalized(relay: string | null, sender: null, amount: null): EventFilter;

    RelayAdded(
      relay: string | null,
      owner: string | null,
      transactionFee: null,
      stake: null,
      unstakeDelay: null,
      url: null
    ): EventFilter;

    RelayRemoved(relay: string | null, unstakeTime: null): EventFilter;

    Staked(relay: string | null, stake: null, unstakeDelay: null): EventFilter;

    TransactionRelayed(
      relay: string | null,
      from: string | null,
      to: string | null,
      selector: null,
      status: null,
      charge: null
    ): EventFilter;

    Unstaked(relay: string | null, stake: null): EventFilter;

    Withdrawn(
      account: string | null,
      dest: string | null,
      amount: null
    ): EventFilter;
  };

  estimateGas: {
    /**
     * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    balanceOf(target: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    "balanceOf(address)"(
      target: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
     */
    canRelay(
      relay: string,
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
     */
    "canRelay(address,address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
      relay: string,
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
     */
    depositFor(
      target: string,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
     */
    "depositFor(address)"(
      target: string,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * Returns an account's nonce in `RelayHub`.
     */
    getNonce(from: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns an account's nonce in `RelayHub`.
     */
    "getNonce(address)"(
      from: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
     */
    getRelay(relay: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
     */
    "getRelay(address)"(
      relay: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    maxPossibleCharge(
      relayedCallStipend: BigNumberish,
      gasPrice: BigNumberish,
      transactionFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    "maxPossibleCharge(uint256,uint256,uint256)"(
      relayedCallStipend: BigNumberish,
      gasPrice: BigNumberish,
      transactionFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    penalizeIllegalTransaction(
      unsignedTx: BytesLike,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    "penalizeIllegalTransaction(bytes,bytes)"(
      unsignedTx: BytesLike,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
     */
    penalizeRepeatedNonce(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
     */
    "penalizeRepeatedNonce(bytes,bytes,bytes,bytes)"(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
     */
    registerRelay(
      transactionFee: BigNumberish,
      url: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
     */
    "registerRelay(uint256,string)"(
      transactionFee: BigNumberish,
      url: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
     */
    relayCall(
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
     */
    "relayCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
     */
    removeRelayByOwner(
      relay: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
     */
    "removeRelayByOwner(address)"(
      relay: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
     */
    requiredGas(
      relayedCallStipend: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
     */
    "requiredGas(uint256)"(
      relayedCallStipend: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
     */
    stake(
      relayaddr: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
     */
    "stake(address,uint256)"(
      relayaddr: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
     */
    unstake(relay: string, overrides?: Overrides): Promise<BigNumber>;

    /**
     * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
     */
    "unstake(address)"(
      relay: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
     */
    withdraw(
      amount: BigNumberish,
      dest: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
     */
    "withdraw(uint256,address)"(
      amount: BigNumberish,
      dest: string,
      overrides?: Overrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    balanceOf(
      target: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    "balanceOf(address)"(
      target: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
     */
    canRelay(
      relay: string,
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Checks if the `RelayHub` will accept a relayed operation. Multiple things must be true for this to happen:  - all arguments must be signed for by the sender (`from`)  - the sender's nonce must be the current one  - the recipient must accept this transaction (via {acceptRelayedCall}) Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error code if it returns one in {acceptRelayedCall}.
     */
    "canRelay(address,address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
      relay: string,
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
     */
    depositFor(
      target: string,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions. Unused balance can only be withdrawn by the contract itself, by calling {withdraw}. Emits a {Deposited} event.
     */
    "depositFor(address)"(
      target: string,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an account's nonce in `RelayHub`.
     */
    getNonce(
      from: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an account's nonce in `RelayHub`.
     */
    "getNonce(address)"(
      from: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
     */
    getRelay(
      relay: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function to return an empty entry.
     */
    "getRelay(address)"(
      relay: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    maxPossibleCharge(
      relayedCallStipend: BigNumberish,
      gasPrice: BigNumberish,
      transactionFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    "maxPossibleCharge(uint256,uint256,uint256)"(
      relayedCallStipend: BigNumberish,
      gasPrice: BigNumberish,
      transactionFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    penalizeIllegalTransaction(
      unsignedTx: BytesLike,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    "penalizeIllegalTransaction(bytes,bytes)"(
      unsignedTx: BytesLike,
      signature: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
     */
    penalizeRepeatedNonce(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and different data (gas price, gas limit, etc. may be different). The (unsigned) transaction data and signature for both transactions must be provided.
     */
    "penalizeRepeatedNonce(bytes,bytes,bytes,bytes)"(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
     */
    registerRelay(
      transactionFee: BigNumberish,
      url: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Registers the caller as a relay. The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA). This function can be called multiple times, emitting new {RelayAdded} events. Note that the received `transactionFee` is not enforced by {relayCall}. Emits a {RelayAdded} event.
     */
    "registerRelay(uint256,string)"(
      transactionFee: BigNumberish,
      url: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
     */
    relayCall(
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Relays a transaction. For this to succeed, multiple conditions must be met:  - {canRelay} must `return PreconditionCheck.OK`  - the sender must be a registered relay  - the transaction's gas price must be larger or equal to the one that was requested by the sender  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the recipient) use all gas available to them  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is spent) If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded function and {postRelayedCall} will be called in that order. Parameters:  - `from`: the client originating the request  - `to`: the target {IRelayRecipient} contract  - `encodedFunction`: the function call to relay, including data  - `transactionFee`: fee (%) the relay takes over actual gas cost  - `gasPrice`: gas price the client is willing to pay  - `gasLimit`: gas to forward when calling the encoded function  - `nonce`: client's nonce  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the `RelayHub`, but it still can be used for e.g. a signature. Emits a {TransactionRelayed} event.
     */
    "relayCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,bytes)"(
      from: string,
      to: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
     */
    removeRelayByOwner(
      relay: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed. Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be callable. Emits a {RelayRemoved} event.
     */
    "removeRelayByOwner(address)"(
      relay: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
     */
    requiredGas(
      relayedCallStipend: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will spend up to `relayedCallStipend` gas.
     */
    "requiredGas(uint256)"(
      relayedCallStipend: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
     */
    stake(
      relayaddr: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay cannot be its own owner. All Ether in this function call will be added to the relay's stake. Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one. Emits a {Staked} event.
     */
    "stake(address,uint256)"(
      relayaddr: string,
      unstakeDelay: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
     */
    unstake(
      relay: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deletes the relay from the system, and gives back its stake to the owner. Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called. Emits an {Unstaked} event.
     */
    "unstake(address)"(
      relay: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
     */
    withdraw(
      amount: BigNumberish,
      dest: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and contracts can use it to reduce their funding. Emits a {Withdrawn} event.
     */
    "withdraw(uint256,address)"(
      amount: BigNumberish,
      dest: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
