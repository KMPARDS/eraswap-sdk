/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { ethers, EventFilter, Signer, BigNumber, BigNumberish, PopulatedTransaction } from 'ethers';
import { Contract, ContractTransaction, Overrides, CallOverrides } from '@ethersproject/contracts';
import { BytesLike } from '@ethersproject/bytes';
import { Listener, Provider } from '@ethersproject/providers';
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi';

interface GsnRecipientInterface extends ethers.utils.Interface {
  functions: {
    'acceptRelayedCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,uint256)': FunctionFragment;
    'getHubAddr()': FunctionFragment;
    'postRelayedCall(bytes,bool,uint256,bytes32)': FunctionFragment;
    'preRelayedCall(bytes)': FunctionFragment;
    'relayHubVersion()': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'acceptRelayedCall',
    values: [
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(functionFragment: 'getHubAddr', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'postRelayedCall',
    values: [BytesLike, boolean, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'preRelayedCall', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'relayHubVersion', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'acceptRelayedCall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getHubAddr', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'postRelayedCall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'preRelayedCall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'relayHubVersion', data: BytesLike): Result;

  events: {
    'RelayHubChanged(address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'RelayHubChanged'): EventFragment;
}

export class GsnRecipient extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: GsnRecipientInterface;

  functions: {
    /**
     * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
     */
    acceptRelayedCall(
      relay: string,
      from: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      approvalData: BytesLike,
      maxPossibleCharge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: string;
    }>;

    /**
     * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
     */
    'acceptRelayedCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,uint256)'(
      relay: string,
      from: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      approvalData: BytesLike,
      maxPossibleCharge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: string;
    }>;

    /**
     * Returns the address of the {IRelayHub} contract for this recipient.
     */
    getHubAddr(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Returns the address of the {IRelayHub} contract for this recipient.
     */
    'getHubAddr()'(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    postRelayedCall(
      context: BytesLike,
      success: boolean,
      actualCharge: BigNumberish,
      preRetVal: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    'postRelayedCall(bytes,bool,uint256,bytes32)'(
      context: BytesLike,
      success: boolean,
      actualCharge: BigNumberish,
      preRetVal: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    preRelayedCall(context: BytesLike, overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    'preRelayedCall(bytes)'(
      context: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    relayHubVersion(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    'relayHubVersion()'(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;
  };

  /**
   * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
   */
  acceptRelayedCall(
    relay: string,
    from: string,
    encodedFunction: BytesLike,
    transactionFee: BigNumberish,
    gasPrice: BigNumberish,
    gasLimit: BigNumberish,
    nonce: BigNumberish,
    approvalData: BytesLike,
    maxPossibleCharge: BigNumberish,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber;
    1: string;
  }>;

  /**
   * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
   */
  'acceptRelayedCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,uint256)'(
    relay: string,
    from: string,
    encodedFunction: BytesLike,
    transactionFee: BigNumberish,
    gasPrice: BigNumberish,
    gasLimit: BigNumberish,
    nonce: BigNumberish,
    approvalData: BytesLike,
    maxPossibleCharge: BigNumberish,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber;
    1: string;
  }>;

  /**
   * Returns the address of the {IRelayHub} contract for this recipient.
   */
  getHubAddr(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the {IRelayHub} contract for this recipient.
   */
  'getHubAddr()'(overrides?: CallOverrides): Promise<string>;

  /**
   * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
   */
  postRelayedCall(
    context: BytesLike,
    success: boolean,
    actualCharge: BigNumberish,
    preRetVal: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
   */
  'postRelayedCall(bytes,bool,uint256,bytes32)'(
    context: BytesLike,
    success: boolean,
    actualCharge: BigNumberish,
    preRetVal: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
   */
  preRelayedCall(context: BytesLike, overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
   */
  'preRelayedCall(bytes)'(context: BytesLike, overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
   */
  relayHubVersion(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
   */
  'relayHubVersion()'(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    /**
     * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
     */
    acceptRelayedCall(
      relay: string,
      from: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      approvalData: BytesLike,
      maxPossibleCharge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: string;
    }>;

    /**
     * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
     */
    'acceptRelayedCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,uint256)'(
      relay: string,
      from: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      approvalData: BytesLike,
      maxPossibleCharge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: string;
    }>;

    /**
     * Returns the address of the {IRelayHub} contract for this recipient.
     */
    getHubAddr(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the {IRelayHub} contract for this recipient.
     */
    'getHubAddr()'(overrides?: CallOverrides): Promise<string>;

    /**
     * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    postRelayedCall(
      context: BytesLike,
      success: boolean,
      actualCharge: BigNumberish,
      preRetVal: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    'postRelayedCall(bytes,bool,uint256,bytes32)'(
      context: BytesLike,
      success: boolean,
      actualCharge: BigNumberish,
      preRetVal: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    preRelayedCall(context: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    'preRelayedCall(bytes)'(context: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    relayHubVersion(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    'relayHubVersion()'(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    RelayHubChanged(oldRelayHub: string | null, newRelayHub: string | null): EventFilter;
  };

  estimateGas: {
    /**
     * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
     */
    acceptRelayedCall(
      relay: string,
      from: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      approvalData: BytesLike,
      maxPossibleCharge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
     */
    'acceptRelayedCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,uint256)'(
      relay: string,
      from: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      approvalData: BytesLike,
      maxPossibleCharge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the address of the {IRelayHub} contract for this recipient.
     */
    getHubAddr(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the {IRelayHub} contract for this recipient.
     */
    'getHubAddr()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    postRelayedCall(
      context: BytesLike,
      success: boolean,
      actualCharge: BigNumberish,
      preRetVal: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    'postRelayedCall(bytes,bool,uint256,bytes32)'(
      context: BytesLike,
      success: boolean,
      actualCharge: BigNumberish,
      preRetVal: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    preRelayedCall(context: BytesLike, overrides?: Overrides): Promise<BigNumber>;

    /**
     * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    'preRelayedCall(bytes)'(context: BytesLike, overrides?: Overrides): Promise<BigNumber>;

    /**
     * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    relayHubVersion(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    'relayHubVersion()'(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
     */
    acceptRelayedCall(
      relay: string,
      from: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      approvalData: BytesLike,
      maxPossibleCharge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not). The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas, and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature over all or some of the previous values. Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code, values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions. {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered rejected. A regular revert will also trigger a rejection.
     */
    'acceptRelayedCall(address,address,bytes,uint256,uint256,uint256,uint256,bytes,uint256)'(
      relay: string,
      from: string,
      encodedFunction: BytesLike,
      transactionFee: BigNumberish,
      gasPrice: BigNumberish,
      gasLimit: BigNumberish,
      nonce: BigNumberish,
      approvalData: BytesLike,
      maxPossibleCharge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the {IRelayHub} contract for this recipient.
     */
    getHubAddr(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the {IRelayHub} contract for this recipient.
     */
    'getHubAddr()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    postRelayedCall(
      context: BytesLike,
      success: boolean,
      actualCharge: BigNumberish,
      preRetVal: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * See `IRelayRecipient.postRelayedCall`. This function should not be overridden directly, use `_postRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    'postRelayedCall(bytes,bool,uint256,bytes32)'(
      context: BytesLike,
      success: boolean,
      actualCharge: BigNumberish,
      preRetVal: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    preRelayedCall(context: BytesLike, overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * See `IRelayRecipient.preRelayedCall`. This function should not be overridden directly, use `_preRelayedCall` instead. * Requirements: - the caller must be the `RelayHub` contract.
     */
    'preRelayedCall(bytes)'(
      context: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    relayHubVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the version string of the {IRelayHub} for which this recipient implementation was built. If {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    'relayHubVersion()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
